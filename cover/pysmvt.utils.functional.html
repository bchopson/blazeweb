<html>
<head>
<title>pysmvt.utils.functional</title>
</head>
<body>
pysmvt.utils.functional
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 68 lines<br/>
Missed: 85 lines<br/>
Skipped 101 lines<br/>
Percent: 44 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># License for code in this file that was taken from Python 2.5.</pre></div>
<div class="skip"><span class="num"><pre>  2</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  3</pre></span><pre># PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2</pre></div>
<div class="skip"><span class="num"><pre>  4</pre></span><pre># --------------------------------------------</pre></div>
<div class="skip"><span class="num"><pre>  5</pre></span><pre>#</pre></div>
<div class="skip"><span class="num"><pre>  6</pre></span><pre># 1. This LICENSE AGREEMENT is between the Python Software Foundation</pre></div>
<div class="skip"><span class="num"><pre>  7</pre></span><pre># (&quot;PSF&quot;), and the Individual or Organization (&quot;Licensee&quot;) accessing and</pre></div>
<div class="skip"><span class="num"><pre>  8</pre></span><pre># otherwise using this software (&quot;Python&quot;) in source or binary form and</pre></div>
<div class="skip"><span class="num"><pre>  9</pre></span><pre># its associated documentation.</pre></div>
<div class="skip"><span class="num"><pre> 10</pre></span><pre>#</pre></div>
<div class="skip"><span class="num"><pre> 11</pre></span><pre># 2. Subject to the terms and conditions of this License Agreement, PSF</pre></div>
<div class="skip"><span class="num"><pre> 12</pre></span><pre># hereby grants Licensee a nonexclusive, royalty-free, world-wide</pre></div>
<div class="skip"><span class="num"><pre> 13</pre></span><pre># license to reproduce, analyze, test, perform and/or display publicly,</pre></div>
<div class="skip"><span class="num"><pre> 14</pre></span><pre># prepare derivative works, distribute, and otherwise use Python</pre></div>
<div class="skip"><span class="num"><pre> 15</pre></span><pre># alone or in any derivative version, provided, however, that PSF's</pre></div>
<div class="skip"><span class="num"><pre> 16</pre></span><pre># License Agreement and PSF's notice of copyright, i.e., &quot;Copyright (c)</pre></div>
<div class="skip"><span class="num"><pre> 17</pre></span><pre># 2001, 2002, 2003, 2004, 2005, 2006, 2007 Python Software Foundation;</pre></div>
<div class="skip"><span class="num"><pre> 18</pre></span><pre># All Rights Reserved&quot; are retained in Python alone or in any derivative</pre></div>
<div class="skip"><span class="num"><pre> 19</pre></span><pre># version prepared by Licensee.</pre></div>
<div class="skip"><span class="num"><pre> 20</pre></span><pre>#</pre></div>
<div class="skip"><span class="num"><pre> 21</pre></span><pre># 3. In the event Licensee prepares a derivative work that is based on</pre></div>
<div class="skip"><span class="num"><pre> 22</pre></span><pre># or incorporates Python or any part thereof, and wants to make</pre></div>
<div class="skip"><span class="num"><pre> 23</pre></span><pre># the derivative work available to others as provided herein, then</pre></div>
<div class="skip"><span class="num"><pre> 24</pre></span><pre># Licensee hereby agrees to include in any such work a brief summary of</pre></div>
<div class="skip"><span class="num"><pre> 25</pre></span><pre># the changes made to Python.</pre></div>
<div class="skip"><span class="num"><pre> 26</pre></span><pre>#</pre></div>
<div class="skip"><span class="num"><pre> 27</pre></span><pre># 4. PSF is making Python available to Licensee on an &quot;AS IS&quot;</pre></div>
<div class="skip"><span class="num"><pre> 28</pre></span><pre># basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR</pre></div>
<div class="skip"><span class="num"><pre> 29</pre></span><pre># IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND</pre></div>
<div class="skip"><span class="num"><pre> 30</pre></span><pre># DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS</pre></div>
<div class="skip"><span class="num"><pre> 31</pre></span><pre># FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT</pre></div>
<div class="skip"><span class="num"><pre> 32</pre></span><pre># INFRINGE ANY THIRD PARTY RIGHTS.</pre></div>
<div class="skip"><span class="num"><pre> 33</pre></span><pre>#</pre></div>
<div class="skip"><span class="num"><pre> 34</pre></span><pre># 5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON</pre></div>
<div class="skip"><span class="num"><pre> 35</pre></span><pre># FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS</pre></div>
<div class="skip"><span class="num"><pre> 36</pre></span><pre># A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,</pre></div>
<div class="skip"><span class="num"><pre> 37</pre></span><pre># OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.</pre></div>
<div class="skip"><span class="num"><pre> 38</pre></span><pre>#</pre></div>
<div class="skip"><span class="num"><pre> 39</pre></span><pre># 6. This License Agreement will automatically terminate upon a material</pre></div>
<div class="skip"><span class="num"><pre> 40</pre></span><pre># breach of its terms and conditions.</pre></div>
<div class="skip"><span class="num"><pre> 41</pre></span><pre>#</pre></div>
<div class="skip"><span class="num"><pre> 42</pre></span><pre># 7. Nothing in this License Agreement shall be deemed to create any</pre></div>
<div class="skip"><span class="num"><pre> 43</pre></span><pre># relationship of agency, partnership, or joint venture between PSF and</pre></div>
<div class="skip"><span class="num"><pre> 44</pre></span><pre># Licensee.  This License Agreement does not grant permission to use PSF</pre></div>
<div class="skip"><span class="num"><pre> 45</pre></span><pre># trademarks or trade name in a trademark sense to endorse or promote</pre></div>
<div class="skip"><span class="num"><pre> 46</pre></span><pre># products or services of Licensee, or any third party.</pre></div>
<div class="skip"><span class="num"><pre> 47</pre></span><pre>#</pre></div>
<div class="skip"><span class="num"><pre> 48</pre></span><pre># 8. By copying, installing or otherwise using Python, Licensee</pre></div>
<div class="skip"><span class="num"><pre> 49</pre></span><pre># agrees to be bound by the terms and conditions of this License</pre></div>
<div class="skip"><span class="num"><pre> 50</pre></span><pre># Agreement.</pre></div>
<div class="skip"><span class="num"><pre> 51</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 52</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 53</pre></span><pre>def curry(_curried_func, *args, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre> 54</pre></span><pre>    def _curried(*moreargs, **morekwargs):</pre></div>
<div class="cov"><span class="num"><pre> 55</pre></span><pre>        return _curried_func(*(args+moreargs), **dict(kwargs, **morekwargs))</pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>    return _curried</pre></div>
<div class="skip"><span class="num"><pre> 57</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 58</pre></span><pre>### Begin from Python 2.5 functools.py ########################################</pre></div>
<div class="skip"><span class="num"><pre> 59</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 60</pre></span><pre># Summary of changes made to the Python 2.5 code below:</pre></div>
<div class="skip"><span class="num"><pre> 61</pre></span><pre>#   * swapped ``partial`` for ``curry`` to maintain backwards-compatibility</pre></div>
<div class="skip"><span class="num"><pre> 62</pre></span><pre>#     in Django.</pre></div>
<div class="skip"><span class="num"><pre> 63</pre></span><pre>#   * Wrapped the ``setattr`` call in ``update_wrapper`` with a try-except</pre></div>
<div class="skip"><span class="num"><pre> 64</pre></span><pre>#     block to make it compatible with Python 2.3, which doesn't allow</pre></div>
<div class="skip"><span class="num"><pre> 65</pre></span><pre>#     assigning to ``__name__``.</pre></div>
<div class="skip"><span class="num"><pre> 66</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 67</pre></span><pre># Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007 Python Software Foundation.</pre></div>
<div class="skip"><span class="num"><pre> 68</pre></span><pre># All Rights Reserved.</pre></div>
<div class="skip"><span class="num"><pre> 69</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 70</pre></span><pre>###############################################################################</pre></div>
<div class="skip"><span class="num"><pre> 71</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 72</pre></span><pre># update_wrapper() and wraps() are tools to help write</pre></div>
<div class="skip"><span class="num"><pre> 73</pre></span><pre># wrapper functions that can handle naive introspection</pre></div>
<div class="skip"><span class="num"><pre> 74</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 75</pre></span><pre>WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>WRAPPER_UPDATES = ('__dict__',)</pre></div>
<div class="cov"><span class="num"><pre> 77</pre></span><pre>def update_wrapper(wrapper,</pre></div>
<div class="cov"><span class="num"><pre> 78</pre></span><pre>                   wrapped,</pre></div>
<div class="cov"><span class="num"><pre> 79</pre></span><pre>                   assigned = WRAPPER_ASSIGNMENTS,</pre></div>
<div class="cov"><span class="num"><pre> 80</pre></span><pre>                   updated = WRAPPER_UPDATES):</pre></div>
<div class="cov"><span class="num"><pre> 81</pre></span><pre>    &quot;&quot;&quot;Update a wrapper function to look like the wrapped function</pre></div>
<div class="skip"><span class="num"><pre> 82</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>       wrapper is the function to be updated</pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>       wrapped is the original function</pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>       assigned is a tuple naming the attributes assigned directly</pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>       from the wrapped function to the wrapper function (defaults to</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>       functools.WRAPPER_ASSIGNMENTS)</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>       updated is a tuple naming the attributes off the wrapper that</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>       are updated with the corresponding attribute from the wrapped</pre></div>
<div class="cov"><span class="num"><pre> 90</pre></span><pre>       function (defaults to functools.WRAPPER_UPDATES)</pre></div>
<div class="cov"><span class="num"><pre> 91</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 92</pre></span><pre>    for attr in assigned:</pre></div>
<div class="cov"><span class="num"><pre> 93</pre></span><pre>        try:</pre></div>
<div class="cov"><span class="num"><pre> 94</pre></span><pre>            setattr(wrapper, attr, getattr(wrapped, attr))</pre></div>
<div class="nocov"><span class="num"><pre> 95</pre></span><pre>        except TypeError: # Python 2.3 doesn't allow assigning to __name__.</pre></div>
<div class="nocov"><span class="num"><pre> 96</pre></span><pre>            pass</pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>    for attr in updated:</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>        getattr(wrapper, attr).update(getattr(wrapped, attr))</pre></div>
<div class="skip"><span class="num"><pre> 99</pre></span><pre>    # Return the wrapper so this can be used as a decorator via curry()</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>    return wrapper</pre></div>
<div class="skip"><span class="num"><pre>101</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>def wraps(wrapped,</pre></div>
<div class="cov"><span class="num"><pre>103</pre></span><pre>          assigned = WRAPPER_ASSIGNMENTS,</pre></div>
<div class="cov"><span class="num"><pre>104</pre></span><pre>          updated = WRAPPER_UPDATES):</pre></div>
<div class="cov"><span class="num"><pre>105</pre></span><pre>    &quot;&quot;&quot;Decorator factory to apply update_wrapper() to a wrapper function</pre></div>
<div class="skip"><span class="num"><pre>106</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>       Returns a decorator that invokes update_wrapper() with the decorated</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>       function as the wrapper argument and the arguments to wraps() as the</pre></div>
<div class="cov"><span class="num"><pre>109</pre></span><pre>       remaining arguments. Default arguments are as for update_wrapper().</pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>       This is a convenience function to simplify applying curry() to</pre></div>
<div class="cov"><span class="num"><pre>111</pre></span><pre>       update_wrapper().</pre></div>
<div class="cov"><span class="num"><pre>112</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>113</pre></span><pre>    return curry(update_wrapper, wrapped=wrapped,</pre></div>
<div class="cov"><span class="num"><pre>114</pre></span><pre>                 assigned=assigned, updated=updated)</pre></div>
<div class="skip"><span class="num"><pre>115</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>116</pre></span><pre>### End from Python 2.5 functools.py ##########################################</pre></div>
<div class="skip"><span class="num"><pre>117</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>118</pre></span><pre>def memoize(func, cache, num_args):</pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>    Wrap a function so that results for any argument tuple are stored in</pre></div>
<div class="cov"><span class="num"><pre>121</pre></span><pre>    'cache'. Note that the args to the function must be usable as dictionary</pre></div>
<div class="cov"><span class="num"><pre>122</pre></span><pre>    keys.</pre></div>
<div class="skip"><span class="num"><pre>123</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>    Only the first num_args are considered when creating the key.</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>126</pre></span><pre>    def wrapper(*args):</pre></div>
<div class="nocov"><span class="num"><pre>127</pre></span><pre>        mem_args = args[:num_args]</pre></div>
<div class="nocov"><span class="num"><pre>128</pre></span><pre>        if mem_args in cache:</pre></div>
<div class="nocov"><span class="num"><pre>129</pre></span><pre>            return cache[mem_args]</pre></div>
<div class="nocov"><span class="num"><pre>130</pre></span><pre>        result = func(*args)</pre></div>
<div class="nocov"><span class="num"><pre>131</pre></span><pre>        cache[mem_args] = result</pre></div>
<div class="nocov"><span class="num"><pre>132</pre></span><pre>        return result</pre></div>
<div class="nocov"><span class="num"><pre>133</pre></span><pre>    return wraps(func)(wrapper)</pre></div>
<div class="skip"><span class="num"><pre>134</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>135</pre></span><pre>class Promise(object):</pre></div>
<div class="cov"><span class="num"><pre>136</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>137</pre></span><pre>    This is just a base class for the proxy class created in</pre></div>
<div class="cov"><span class="num"><pre>138</pre></span><pre>    the closure of the lazy function. It can be used to recognize</pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>    promises in code.</pre></div>
<div class="cov"><span class="num"><pre>140</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>141</pre></span><pre>    pass</pre></div>
<div class="skip"><span class="num"><pre>142</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>def lazy(func, *resultclasses):</pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>145</pre></span><pre>    Turns any callable into a lazy evaluated callable. You need to give result</pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>    classes or types -- at least one is needed so that the automatic forcing of</pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>    the lazy evaluation code is triggered. Results are not memoized; the</pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>    function is evaluated on every access.</pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>150</pre></span><pre>    class __proxy__(Promise):</pre></div>
<div class="nocov"><span class="num"><pre>151</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>152</pre></span><pre>        Encapsulate a function call and act as a proxy for methods that are</pre></div>
<div class="nocov"><span class="num"><pre>153</pre></span><pre>        called on the result of that function. The function is not evaluated</pre></div>
<div class="nocov"><span class="num"><pre>154</pre></span><pre>        until one of the methods on the result is called.</pre></div>
<div class="nocov"><span class="num"><pre>155</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>156</pre></span><pre>        __dispatch = None</pre></div>
<div class="skip"><span class="num"><pre>157</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>158</pre></span><pre>        def __init__(self, args, kw):</pre></div>
<div class="nocov"><span class="num"><pre>159</pre></span><pre>            self.__func = func</pre></div>
<div class="nocov"><span class="num"><pre>160</pre></span><pre>            self.__args = args</pre></div>
<div class="nocov"><span class="num"><pre>161</pre></span><pre>            self.__kw = kw</pre></div>
<div class="nocov"><span class="num"><pre>162</pre></span><pre>            if self.__dispatch is None:</pre></div>
<div class="nocov"><span class="num"><pre>163</pre></span><pre>                self.__prepare_class__()</pre></div>
<div class="skip"><span class="num"><pre>164</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>165</pre></span><pre>        def __prepare_class__(cls):</pre></div>
<div class="nocov"><span class="num"><pre>166</pre></span><pre>            cls.__dispatch = {}</pre></div>
<div class="nocov"><span class="num"><pre>167</pre></span><pre>            for resultclass in resultclasses:</pre></div>
<div class="nocov"><span class="num"><pre>168</pre></span><pre>                cls.__dispatch[resultclass] = {}</pre></div>
<div class="nocov"><span class="num"><pre>169</pre></span><pre>                for (k, v) in resultclass.__dict__.items():</pre></div>
<div class="nocov"><span class="num"><pre>170</pre></span><pre>                    if hasattr(cls, k):</pre></div>
<div class="nocov"><span class="num"><pre>171</pre></span><pre>                        continue</pre></div>
<div class="nocov"><span class="num"><pre>172</pre></span><pre>                    setattr(cls, k, cls.__promise__(resultclass, k, v))</pre></div>
<div class="nocov"><span class="num"><pre>173</pre></span><pre>            cls._delegate_str = str in resultclasses</pre></div>
<div class="nocov"><span class="num"><pre>174</pre></span><pre>            cls._delegate_unicode = unicode in resultclasses</pre></div>
<div class="nocov"><span class="num"><pre>175</pre></span><pre>            assert not (cls._delegate_str and cls._delegate_unicode), &quot;Cannot call lazy() with both str and unicode return types.&quot;</pre></div>
<div class="nocov"><span class="num"><pre>176</pre></span><pre>            if cls._delegate_unicode:</pre></div>
<div class="nocov"><span class="num"><pre>177</pre></span><pre>                cls.__unicode__ = cls.__unicode_cast</pre></div>
<div class="nocov"><span class="num"><pre>178</pre></span><pre>            elif cls._delegate_str:</pre></div>
<div class="nocov"><span class="num"><pre>179</pre></span><pre>                cls.__str__ = cls.__str_cast</pre></div>
<div class="nocov"><span class="num"><pre>180</pre></span><pre>        __prepare_class__ = classmethod(__prepare_class__)</pre></div>
<div class="skip"><span class="num"><pre>181</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>182</pre></span><pre>        def __promise__(cls, klass, funcname, func):</pre></div>
<div class="skip"><span class="num"><pre>183</pre></span><pre>            # Builds a wrapper around some magic method and registers that magic</pre></div>
<div class="skip"><span class="num"><pre>184</pre></span><pre>            # method for the given type and method name.</pre></div>
<div class="nocov"><span class="num"><pre>185</pre></span><pre>            def __wrapper__(self, *args, **kw):</pre></div>
<div class="skip"><span class="num"><pre>186</pre></span><pre>                # Automatically triggers the evaluation of a lazy value and</pre></div>
<div class="skip"><span class="num"><pre>187</pre></span><pre>                # applies the given magic method of the result type.</pre></div>
<div class="nocov"><span class="num"><pre>188</pre></span><pre>                res = self.__func(*self.__args, **self.__kw)</pre></div>
<div class="nocov"><span class="num"><pre>189</pre></span><pre>                for t in type(res).mro():</pre></div>
<div class="nocov"><span class="num"><pre>190</pre></span><pre>                    if t in self.__dispatch:</pre></div>
<div class="nocov"><span class="num"><pre>191</pre></span><pre>                        return self.__dispatch[t][funcname](res, *args, **kw)</pre></div>
<div class="nocov"><span class="num"><pre>192</pre></span><pre>                raise TypeError(&quot;Lazy object returned unexpected type.&quot;)</pre></div>
<div class="skip"><span class="num"><pre>193</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>194</pre></span><pre>            if klass not in cls.__dispatch:</pre></div>
<div class="nocov"><span class="num"><pre>195</pre></span><pre>                cls.__dispatch[klass] = {}</pre></div>
<div class="nocov"><span class="num"><pre>196</pre></span><pre>            cls.__dispatch[klass][funcname] = func</pre></div>
<div class="nocov"><span class="num"><pre>197</pre></span><pre>            return __wrapper__</pre></div>
<div class="nocov"><span class="num"><pre>198</pre></span><pre>        __promise__ = classmethod(__promise__)</pre></div>
<div class="skip"><span class="num"><pre>199</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>200</pre></span><pre>        def __unicode_cast(self):</pre></div>
<div class="nocov"><span class="num"><pre>201</pre></span><pre>            return self.__func(*self.__args, **self.__kw)</pre></div>
<div class="skip"><span class="num"><pre>202</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>203</pre></span><pre>        def __str_cast(self):</pre></div>
<div class="nocov"><span class="num"><pre>204</pre></span><pre>            return str(self.__func(*self.__args, **self.__kw))</pre></div>
<div class="skip"><span class="num"><pre>205</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>206</pre></span><pre>        def __cmp__(self, rhs):</pre></div>
<div class="nocov"><span class="num"><pre>207</pre></span><pre>            if self._delegate_str:</pre></div>
<div class="nocov"><span class="num"><pre>208</pre></span><pre>                s = str(self.__func(*self.__args, **self.__kw))</pre></div>
<div class="nocov"><span class="num"><pre>209</pre></span><pre>            elif self._delegate_unicode:</pre></div>
<div class="nocov"><span class="num"><pre>210</pre></span><pre>                s = unicode(self.__func(*self.__args, **self.__kw))</pre></div>
<div class="nocov"><span class="num"><pre>211</pre></span><pre>            else:</pre></div>
<div class="nocov"><span class="num"><pre>212</pre></span><pre>                s = self.__func(*self.__args, **self.__kw)</pre></div>
<div class="nocov"><span class="num"><pre>213</pre></span><pre>            if isinstance(rhs, Promise):</pre></div>
<div class="nocov"><span class="num"><pre>214</pre></span><pre>                return -cmp(rhs, s)</pre></div>
<div class="nocov"><span class="num"><pre>215</pre></span><pre>            else:</pre></div>
<div class="nocov"><span class="num"><pre>216</pre></span><pre>                return cmp(s, rhs)</pre></div>
<div class="skip"><span class="num"><pre>217</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>218</pre></span><pre>        def __mod__(self, rhs):</pre></div>
<div class="nocov"><span class="num"><pre>219</pre></span><pre>            if self._delegate_str:</pre></div>
<div class="nocov"><span class="num"><pre>220</pre></span><pre>                return str(self) % rhs</pre></div>
<div class="nocov"><span class="num"><pre>221</pre></span><pre>            elif self._delegate_unicode:</pre></div>
<div class="nocov"><span class="num"><pre>222</pre></span><pre>                return unicode(self) % rhs</pre></div>
<div class="nocov"><span class="num"><pre>223</pre></span><pre>            else:</pre></div>
<div class="nocov"><span class="num"><pre>224</pre></span><pre>                raise AssertionError('__mod__ not supported for non-string types')</pre></div>
<div class="skip"><span class="num"><pre>225</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>226</pre></span><pre>        def __deepcopy__(self, memo):</pre></div>
<div class="skip"><span class="num"><pre>227</pre></span><pre>            # Instances of this class are effectively immutable. It's just a</pre></div>
<div class="skip"><span class="num"><pre>228</pre></span><pre>            # collection of functions. So we don't need to do anything</pre></div>
<div class="skip"><span class="num"><pre>229</pre></span><pre>            # complicated for copying.</pre></div>
<div class="nocov"><span class="num"><pre>230</pre></span><pre>            memo[id(self)] = self</pre></div>
<div class="nocov"><span class="num"><pre>231</pre></span><pre>            return self</pre></div>
<div class="skip"><span class="num"><pre>232</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>233</pre></span><pre>    def __wrapper__(*args, **kw):</pre></div>
<div class="skip"><span class="num"><pre>234</pre></span><pre>        # Creates the proxy object, instead of the actual value.</pre></div>
<div class="nocov"><span class="num"><pre>235</pre></span><pre>        return __proxy__(args, kw)</pre></div>
<div class="skip"><span class="num"><pre>236</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>237</pre></span><pre>    return wraps(func)(__wrapper__)</pre></div>
<div class="skip"><span class="num"><pre>238</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>239</pre></span><pre>def allow_lazy(func, *resultclasses):</pre></div>
<div class="cov"><span class="num"><pre>240</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>241</pre></span><pre>    A decorator that allows a function to be called with one or more lazy</pre></div>
<div class="cov"><span class="num"><pre>242</pre></span><pre>    arguments. If none of the args are lazy, the function is evaluated</pre></div>
<div class="cov"><span class="num"><pre>243</pre></span><pre>    immediately, otherwise a __proxy__ is returned that will evaluate the</pre></div>
<div class="cov"><span class="num"><pre>244</pre></span><pre>    function when needed.</pre></div>
<div class="cov"><span class="num"><pre>245</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>246</pre></span><pre>    def wrapper(*args, **kwargs):</pre></div>
<div class="nocov"><span class="num"><pre>247</pre></span><pre>        for arg in list(args) + kwargs.values():</pre></div>
<div class="nocov"><span class="num"><pre>248</pre></span><pre>            if isinstance(arg, Promise):</pre></div>
<div class="nocov"><span class="num"><pre>249</pre></span><pre>                break</pre></div>
<div class="nocov"><span class="num"><pre>250</pre></span><pre>        else:</pre></div>
<div class="nocov"><span class="num"><pre>251</pre></span><pre>            return func(*args, **kwargs)</pre></div>
<div class="nocov"><span class="num"><pre>252</pre></span><pre>        return lazy(func, *resultclasses)(*args, **kwargs)</pre></div>
<div class="cov"><span class="num"><pre>253</pre></span><pre>    return wraps(func)(wrapper)</pre></div>
<div class="skip"><span class="num"><pre>254</pre></span><pre></pre></div>
</div>
</body>
</html>
